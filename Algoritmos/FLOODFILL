#include <iostream>
#include <queue>
#include <vector>
#include <array>

using namespace std;

// Direcciones (Norte, Este, Sur, Oeste)
int dx[4] = {0, 1, 0, -1};
int dy[4] = {-1, 0, 1, 0};
string dirName[4] = {"Norte", "Este", "Sur", "Oeste"};

// Estructura de cada celda
struct Cell {
    bool walls[4];  // Paredes: N, E, S, O
    int dist;       // Distancia calculada
    bool visited;   // Si ya fue visitada
};

// Laberinto dinámico
vector<vector<Cell>> maze;
int N;  // Tamaño del laberinto

// Inicializa el laberinto
void initMaze() {
    maze.assign(N, vector<Cell>(N));

    for (int y = 0; y < N; y++) {
        for (int x = 0; x < N; x++) {
            for (int d = 0; d < 4; d++) {
                maze[y][x].walls[d] = false;
            }
            maze[y][x].dist = 999;
            maze[y][x].visited = false;
        }
    }

    // Paredes externas
    for (int i = 0; i < N; i++) {
        maze[0][i].walls[0] = true;     // borde norte
        maze[N-1][i].walls[2] = true;   // borde sur
        maze[i][0].walls[3] = true;     // borde oeste
        maze[i][N-1].walls[1] = true;   // borde este
    }
}

// Flood Fill desde múltiples metas
void floodFill(vector<pair<int,int>> metas) {
    queue<pair<int,int>> q;

    // Resetear distancias
    for (int y = 0; y < N; y++) {
        for (int x = 0; x < N; x++) {
            maze[y][x].dist = 999;
        }
    }

    // Inicializar todas las metas
    for (auto [gx, gy] : metas) {
        maze[gy][gx].dist = 0;
        q.push({gx, gy});
    }

    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();

        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            if (maze[y][x].walls[d]) continue;

            if (maze[ny][nx].dist > maze[y][x].dist + 1) {
                maze[ny][nx].dist = maze[y][x].dist + 1;
                q.push({nx, ny});
            }
        }
    }
}

// Simular recorrido
void solveMaze(int startX, int startY, vector<pair<int,int>> metas) {
    int x = startX, y = startY;
    cout << "Inicio en (" << x << "," << y << ")\n";

    // Función para verificar si estamos en una meta
    auto esMeta = [&](int cx, int cy) {
        for (auto [gx, gy] : metas) {
            if (cx == gx && cy == gy) return true;
        }
        return false;
    };

    while (!esMeta(x,y)) {
        int bestDir = -1;
        int bestDist = 999;

        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            if (maze[y][x].walls[d]) continue;

            if (maze[ny][nx].dist < bestDist) {
                bestDist = maze[ny][nx].dist;
                bestDir = d;
            }
        }

        if (bestDir == -1) {
            cout << "¡Atascado! No hay camino.\n";
            return;
        }

        x += dx[bestDir];
        y += dy[bestDir];
        cout << "Mover " << dirName[bestDir] 
             << " → nueva pos (" << x << "," << y << ")\n";
    }

    cout << "¡Meta alcanzada en (" << x << "," << y << ")!\n";
}

int main() {
    int metaTipo;
    int gx, gy;

    cout << "Ingrese tamaño del laberinto N: ";
    cin >> N;
    initMaze();

    cout << "Seleccione tipo de meta:\n";
    cout << "1. Meta única (1x1)\n";
    cout << "2. Meta bloque 2x2\n";
    cout << "3. Meta bloque 2x1 (horizontal)\n";
    cout << "4. Meta bloque 1x2 (vertical)\n";
    cin >> metaTipo;

    cout << "Ingrese coordenada inferior-izquierda de la meta (x y): ";
    cin >> gx >> gy;

    vector<pair<int,int>> metas;

    if (metaTipo == 1) {
        metas.push_back({gx, gy});
    } 
    else if (metaTipo == 2) {
        metas = {{gx,gy}, {gx+1,gy}, {gx,gy+1}, {gx+1,gy+1}};
    } 
    else if (metaTipo == 3) {
        metas = {{gx,gy}, {gx+1,gy}};
    } 
    else if (metaTipo == 4) {
        metas = {{gx,gy}, {gx,gy+1}};
    } else {
        cout << "Opción inválida\n";
        return 0;
    }

    // --- Recorrido de ida ---
    cout << "\n==== RECORRIDO ENTRADA → META ====\n";
    floodFill(metas);
    solveMaze(0, 0, metas);   // desde entrada (0,0) hasta la meta

    // --- Recorrido de regreso ---
    cout << "\n==== RECORRIDO META → ENTRADA ====\n";
    vector<pair<int,int>> entrada = {{0,0}}; // la entrada es la nueva meta
    floodFill(entrada);
    solveMaze(gx, gy, entrada);  // desde la meta de ida hasta la entrada

    return 0;
}
