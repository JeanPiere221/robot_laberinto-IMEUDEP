#include <iostream>
#include <queue>
#include <vector>
#include <array>
#include <algorithm>
using namespace std;

// Direcciones (Norte, Este, Sur, Oeste)
int dx[4] = {0, 1, 0, -1};
int dy[4] = {-1, 0, 1, 0};
string dirName[4] = {"Norte", "Este", "Sur", "Oeste"};

// Estructura de cada celda
struct Cell {
    bool walls[4]; // Paredes: N, E, S, O
    int dist;      // Distancia calculada
    bool visited;  // Si ya fue visitada
};

// Laberinto dinámico
vector<vector<Cell>> maze;
int N; // Tamaño del laberinto

// Inicializa el laberinto
void initMaze() {
    maze.assign(N, vector<Cell>(N));
    for (int y = 0; y < N; y++) {
        for (int x = 0; x < N; x++) {
            for (int d = 0; d < 4; d++) {
                maze[y][x].walls[d] = false;
            }
            maze[y][x].dist = 999;
            maze[y][x].visited = false;
        }
    }
    
    // Paredes externas
    for (int i = 0; i < N; i++) {
        maze[0][i].walls[0] = true;    // borde norte
        maze[N-1][i].walls[2] = true;  // borde sur
        maze[i][0].walls[3] = true;    // borde oeste
        maze[i][N-1].walls[1] = true;  // borde este
    }
}

// Visualizar el laberinto
void printMaze() {
    cout << "\nVisualización del Laberinto:\n";
    for (int y = 0; y < N; y++) {
        // Paredes superiores
        for (int x = 0; x < N; x++) {
            cout << "+";
            if (maze[y][x].walls[0]) cout << "---";
            else cout << "   ";
        }
        cout << "+\n";
        
        // Paredes laterales y contenido
        for (int x = 0; x < N; x++) {
            if (maze[y][x].walls[3]) cout << "|";
            else cout << " ";
            
            if (maze[y][x].dist < 10) cout << " " << maze[y][x].dist << " ";
            else if (maze[y][x].dist < 100) cout << maze[y][x].dist << " ";
            else cout << "## ";
        }
        if (maze[y][N-1].walls[1]) cout << "|";
        else cout << " ";
        cout << "\n";
    }
    
    // Última línea
    for (int x = 0; x < N; x++) {
        cout << "+";
        if (maze[N-1][x].walls[2]) cout << "---";
        else cout << "   ";
    }
    cout << "+\n";
}

// Flood Fill desde múltiples metas
void floodFill(vector<pair<int,int>> metas) {
    queue<pair<int,int>> q;
    
    // Resetear distancias
    for (int y = 0; y < N; y++) {
        for (int x = 0; x < N; x++) {
            maze[y][x].dist = 999;
        }
    }
    
    // Inicializar todas las metas
    for (auto meta : metas) {
        int gx = meta.first;
        int gy = meta.second;
        if (gx >= 0 && gx < N && gy >= 0 && gy < N) {
            maze[gy][gx].dist = 0;
            q.push({gx, gy});
        }
    }
    
    while (!q.empty()) {
        auto current = q.front();
        int x = current.first;
        int y = current.second;
        q.pop();
        
        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            if (maze[y][x].walls[d]) continue;
            
            if (maze[ny][nx].dist > maze[y][x].dist + 1) {
                maze[ny][nx].dist = maze[y][x].dist + 1;
                q.push({nx, ny});
            }
        }
    }
}

// Simular recorrido
void solveMaze(int startX, int startY, vector<pair<int,int>> metas) {
    int x = startX, y = startY;
    cout << "Inicio en (" << x << "," << y << ")\n";
    
    // Función para verificar si estamos en una meta
    auto esMeta = [&](int cx, int cy) {
        for (auto meta : metas) {
            if (cx == meta.first && cy == meta.second) return true;
        }
        return false;
    };
    
    int steps = 0;
    while (!esMeta(x,y) && steps < N*N*2) {
        steps++;
        int bestDir = -1;
        int bestDist = 999;
        
        for (int d = 0; d < 4; d++) {
            int nx = x + dx[d];
            int ny = y + dy[d];
            
            if (nx < 0 || ny < 0 || nx >= N || ny >= N) continue;
            if (maze[y][x].walls[d]) continue;
            
            if (maze[ny][nx].dist < bestDist) {
                bestDist = maze[ny][nx].dist;
                bestDir = d;
            }
        }
        
        if (bestDir == -1) {
            cout << "¡Atascado! No hay camino desde (" << x << "," << y << ") a la meta.\n";
            return;
        }
        
        x += dx[bestDir];
        y += dy[bestDir];
        cout << "Mover " << dirName[bestDir] << " → nueva pos (" << x << "," << y << ")\n";
    }
    
    if (steps >= N*N*2) {
        cout << "¡Búsqueda abortada! Demasiados pasos sin encontrar la meta.\n";
    } else {
        cout << "¡Meta alcanzada en (" << x << "," << y << ")!\n";
    }
}

int main() {
    int metaTipo;
    int gx, gy;
    
    cout << "=== SIMULADOR DE LABERINTO CON FLOOD FILL ===\n\n";
    cout << "Ingrese tamaño del laberinto N: ";
    cin >> N;
    
    if (N <= 0 || N > 20) {
        cout << "Tamaño no válido. Usando valor por defecto N=5.\n";
        N = 5;
    }
    
    initMaze();
    
    cout << "\nSeleccione tipo de meta:\n";
    cout << "1. Meta única (1x1)\n";
    cout << "2. Meta bloque 2x2\n";
    cout << "3. Meta bloque 2x1 (horizontal)\n";
    cout << "4. Meta bloque 1x2 (vertical)\n";
    cout << "Opción: ";
    cin >> metaTipo;
    
    cout << "Ingrese coordenada inferior-izquierda de la meta (x y): ";
    cin >> gx >> gy;
    
    // Validar coordenadas
    if (gx < 0 || gx >= N || gy < 0 || gy >= N) {
        cout << "Coordenadas fuera de rango. Usando (0,0) como meta.\n";
        gx = 0;
        gy = 0;
    }
    
    vector<pair<int,int>> metas;
    
    if (metaTipo == 1) {
        metas.push_back({gx, gy});
        cout << "Meta única en (" << gx << "," << gy << ")\n";
    } else if (metaTipo == 2) {
        // Validar que el bloque 2x2 quepa
        if (gx+1 >= N || gy+1 >= N) {
            cout << "El bloque 2x2 no cabe en esta posición. Usando meta única.\n";
            metas.push_back({gx, gy});
        } else {
            metas = {{gx,gy}, {gx+1,gy}, {gx,gy+1}, {gx+1,gy+1}};
            cout << "Meta 2x2 desde (" << gx << "," << gy << ") a (" << gx+1 << "," << gy+1 << ")\n";
        }
    } else if (metaTipo == 3) {
        // Validar que el bloque 2x1 quepa
        if (gx+1 >= N) {
            cout << "El bloque 2x1 horizontal no cabe. Usando meta única.\n";
            metas.push_back({gx, gy});
        } else {
            metas = {{gx,gy}, {gx+1,gy}};
            cout << "Meta 2x1 horizontal en (" << gx << "," << gy << ") y (" << gx+1 << "," << gy << ")\n";
        }
    } else if (metaTipo == 4) {
        // Validar que el bloque 1x2 quepa
        if (gy+1 >= N) {
            cout << "El bloque 1x2 vertical no cabe. Usando meta única.\n";
            metas.push_back({gx, gy});
        } else {
            metas = {{gx,gy}, {gx,gy+1}};
            cout << "Meta 1x2 vertical en (" << gx << "," << gy << ") y (" << gx << "," << gy+1 << ")\n";
        }
    } else {
        cout << "Opción inválida. Usando meta única por defecto.\n";
        metas.push_back({gx, gy});
    }
    
    // --- Recorrido de ida ---
    cout << "\n==== RECORRIDO ENTRADA → META ====\n";
    floodFill(metas);
    printMaze();
    solveMaze(0, 0, metas); // desde entrada (0,0) hasta la meta
    
    // --- Recorrido de regreso ---
    cout << "\n==== RECORRIDO META → ENTRADA ====\n";
    vector<pair<int,int>> entrada = {{0,0}}; // la entrada es la nueva meta
    floodFill(entrada);
    printMaze();
    
    // Elegir un punto de partida para el regreso (cualquier punto de la meta)
    int startBackX = metas[0].first;
    int startBackY = metas[0].second;
    solveMaze(startBackX, startBackY, entrada);
    
    return 0;
}
